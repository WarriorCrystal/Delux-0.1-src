//Deobfuscated with https://github.com/PetoPetko/Minecraft-Deobfuscator3000 using mappings "1.12 stable mappings"!

// 
// Decompiled by Procyon v0.5.36
// 

package me.travis.wurstplus.wurstplustwo.hacks.exploit;

import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketUseEntity;
import net.minecraft.block.Block;
import net.minecraft.block.BlockChest;
import net.minecraft.item.ItemBlock;
import net.minecraft.item.ItemStack;
import net.minecraft.inventory.ClickType;
import net.minecraft.item.ItemShulkerBox;
import net.minecraft.init.Items;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.EnumHand;
import net.minecraft.entity.passive.AbstractChestHorse;
import java.util.Comparator;
import java.util.function.Predicate;
import net.minecraft.entity.Entity;
import org.lwjgl.input.Keyboard;
import me.travis.wurstplus.wurstplustwo.hacks.WurstplusCategory;
import net.minecraftforge.event.entity.EntityJoinWorldEvent;
import me.zero.alpine.fork.listener.EventHandler;
import me.travis.wurstplus.wurstplustwo.event.events.WurstplusEventMove;
import me.zero.alpine.fork.listener.Listener;
import me.travis.wurstplus.wurstplustwo.util.WurstplusTimer;
import net.minecraft.client.gui.inventory.GuiScreenHorseInventory;
import me.travis.wurstplus.wurstplustwo.guiscreen.settings.WurstplusSetting;
import me.travis.wurstplus.wurstplustwo.hacks.WurstplusHack;

public class AutoSalC1Dupe extends WurstplusHack
{
    WurstplusSetting shulkerOnly;
    WurstplusSetting hitGround;
    WurstplusSetting Delay;
    private boolean doDrop;
    private boolean doChest;
    private boolean doSneak;
    private boolean start;
    private boolean finished;
    private boolean grounded;
    private int itemsToDupe;
    private int itemsMoved;
    private int itemsDropped;
    private GuiScreenHorseInventory l_Chest;
    private final WurstplusTimer timer;
    private boolean noBypass;
    @EventHandler
    private final Listener<WurstplusEventMove> updateListener;
    @EventHandler
    private final Listener<EntityJoinWorldEvent> OnWorldEvent;
    
    public AutoSalC1Dupe() {
        super(WurstplusCategory.WURSTPLUS_EXPLOIT);
        this.shulkerOnly = this.create("OnlyShulkers", "AutoDupeShulkerOnly", true);
        this.hitGround = this.create("GroundCheck", "AutoDupeGround", true);
        this.Delay = this.create("Delay", "AutoDupeDelay", 1.52, 0.15, 10.0);
        this.doDrop = false;
        this.doChest = false;
        this.doSneak = false;
        this.start = false;
        this.finished = false;
        this.grounded = false;
        this.timer = new WurstplusTimer();
        this.noBypass = false;
        Entity l_Entity;
        AbstractChestHorse l_entity;
        int l_Slot;
        int l_I;
        ItemStack l_Stack;
        this.updateListener = new Listener<WurstplusEventMove>(p_Event -> {
            if (Keyboard.isKeyDown(1)) {
                this.toggle();
            }
            else if (this.finished) {
                this.finished = false;
                this.itemsMoved = 0;
                this.itemsDropped = 0;
                this.start = true;
            }
            else if (this.timer.passed((long)(this.Delay.get_value(0) * 100.0f))) {
                this.timer.reset();
                if (this.doSneak) {
                    if (!AutoSalC1Dupe.mc.player.isSneaking()) {
                        AutoSalC1Dupe.mc.gameSettings.keyBindSneak.pressed = true;
                    }
                    else {
                        AutoSalC1Dupe.mc.gameSettings.keyBindSneak.pressed = false;
                        this.doSneak = false;
                        if (!this.hitGround.get_value(true)) {
                            this.finished = true;
                        }
                        else {
                            this.grounded = true;
                        }
                    }
                }
                else if (this.grounded && AutoSalC1Dupe.mc.player.onGround) {
                    this.grounded = false;
                    this.finished = true;
                }
                else {
                    if (this.start && this.is_active()) {
                        this.itemsToDupe = 0;
                        this.itemsMoved = 0;
                        l_Entity = (Entity)AutoSalC1Dupe.mc.world.loadedEntityList.stream().filter(this::isValidEntity).min(Comparator.comparing(p_Entity -> AutoSalC1Dupe.mc.player.getDistance(p_Entity))).orElse(null);
                        if (l_Entity instanceof AbstractChestHorse) {
                            l_entity = (AbstractChestHorse)l_Entity;
                            if (!l_entity.hasChest()) {
                                l_Slot = this.getChestInHotbar();
                                if (l_Slot != -1 && AutoSalC1Dupe.mc.player.inventory.currentItem != l_Slot) {
                                    AutoSalC1Dupe.mc.player.inventory.currentItem = l_Slot;
                                    AutoSalC1Dupe.mc.playerController.updateController();
                                    AutoSalC1Dupe.mc.playerController.interactWithEntity((EntityPlayer)AutoSalC1Dupe.mc.player, (Entity)l_entity, EnumHand.MAIN_HAND);
                                }
                                else if (AutoSalC1Dupe.mc.player.inventory.currentItem != l_Slot) {
                                    this.toggle();
                                    return;
                                }
                                else {
                                    AutoSalC1Dupe.mc.playerController.interactWithEntity((EntityPlayer)AutoSalC1Dupe.mc.player, (Entity)l_entity, EnumHand.MAIN_HAND);
                                }
                            }
                            this.start = false;
                            AutoSalC1Dupe.mc.playerController.interactWithEntity((EntityPlayer)AutoSalC1Dupe.mc.player, (Entity)l_entity, EnumHand.MAIN_HAND);
                            AutoSalC1Dupe.mc.player.sendHorseInventory();
                            this.doChest = true;
                        }
                    }
                    if (this.doChest && !(AutoSalC1Dupe.mc.currentScreen instanceof GuiScreenHorseInventory)) {
                        this.doChest = false;
                        this.start = true;
                    }
                    else if (AutoSalC1Dupe.mc.currentScreen instanceof GuiScreenHorseInventory) {
                        this.l_Chest = (GuiScreenHorseInventory)AutoSalC1Dupe.mc.currentScreen;
                        this.itemsToDupe = this.getItemsToDupe();
                        l_I = 2;
                        while (l_I < this.l_Chest.horseInventory.getSizeInventory() + 1) {
                            l_Stack = this.l_Chest.horseInventory.getStackInSlot(l_I);
                            if ((this.itemsToDupe != 0 && this.itemsMoved != this.l_Chest.horseInventory.getSizeInventory() - 2) || !this.doChest) {
                                if (this.itemsDropped >= this.itemsMoved && this.doDrop) {
                                    break;
                                }
                                else if ((l_Stack.isEmpty() || l_Stack.getItem() == Items.AIR) && this.doChest) {
                                    this.HandleStoring(this.l_Chest.inventorySlots.windowId, this.l_Chest.horseInventory.getSizeInventory() - 9);
                                    --this.itemsToDupe;
                                    this.itemsMoved = this.getItemsInRidingEntity();
                                    return;
                                }
                                else if (!this.doChest && (!this.shulkerOnly.get_value(true) || l_Stack.getItem() instanceof ItemShulkerBox) && !l_Stack.isEmpty() && this.doDrop) {
                                    if (this.canStore()) {
                                        AutoSalC1Dupe.mc.playerController.windowClick(AutoSalC1Dupe.mc.player.openContainer.windowId, l_I, 0, ClickType.QUICK_MOVE, (EntityPlayer)AutoSalC1Dupe.mc.player);
                                    }
                                    else {
                                        AutoSalC1Dupe.mc.playerController.windowClick(this.l_Chest.inventorySlots.windowId, l_I, -999, ClickType.THROW, (EntityPlayer)AutoSalC1Dupe.mc.player);
                                    }
                                    ++this.itemsDropped;
                                    return;
                                }
                                else {
                                    ++l_I;
                                }
                            }
                            else {
                                break;
                            }
                        }
                        if (this.doChest) {
                            this.doChest = false;
                            this.doDupe();
                        }
                        else if (this.doDrop) {
                            this.doDrop = false;
                            AutoSalC1Dupe.mc.player.closeScreen();
                            AutoSalC1Dupe.mc.gameSettings.keyBindSneak.pressed = true;
                            this.doSneak = true;
                        }
                    }
                }
            }
            return;
        }, (Predicate<WurstplusEventMove>[])new Predicate[0]);
        this.OnWorldEvent = new Listener<EntityJoinWorldEvent>(event -> {
            if (event.getEntity() == AutoSalC1Dupe.mc.player) {
                this.toggle();
            }
            return;
        }, (Predicate<EntityJoinWorldEvent>[])new Predicate[0]);
        this.name = "SalC1 Dupe";
        this.tag = "AutoSalC1Dupe";
        this.description = "performs the salc1 treemc dupe automatically";
    }
    
    @Override
    protected void enable() {
        super.enable();
        this.timer.reset();
        this.start = true;
    }
    
    @Override
    protected void disable() {
        super.disable();
        this.noBypass = false;
        this.doDrop = false;
        this.doChest = false;
        this.doSneak = false;
        this.start = false;
        this.finished = false;
        this.grounded = false;
        this.itemsToDupe = 0;
        this.itemsMoved = 0;
        this.itemsDropped = 0;
        this.timer.reset();
    }
    
    private boolean isValidEntity(final Entity entity) {
        if (!(entity instanceof AbstractChestHorse)) {
            return false;
        }
        final AbstractChestHorse l_ChestHorse = (AbstractChestHorse)entity;
        return !l_ChestHorse.isChild() && l_ChestHorse.isTame();
    }
    
    private int getChestInHotbar() {
        for (int i = 0; i < 9; ++i) {
            final ItemStack stack = AutoSalC1Dupe.mc.player.inventory.getStackInSlot(i);
            if (stack != ItemStack.EMPTY && stack.getItem() instanceof ItemBlock) {
                final Block block = ((ItemBlock)stack.getItem()).getBlock();
                if (block instanceof BlockChest) {
                    return i;
                }
            }
        }
        return -1;
    }
    
    private void HandleStoring(final int p_WindowId, final int p_Slot) {
        for (int l_Y = 9; l_Y < AutoSalC1Dupe.mc.player.inventoryContainer.inventorySlots.size() - 1; ++l_Y) {
            final ItemStack l_InvStack = AutoSalC1Dupe.mc.player.inventoryContainer.getSlot(l_Y).getStack();
            if (!l_InvStack.isEmpty() && l_InvStack.getItem() != Items.AIR && (l_InvStack.getItem() instanceof ItemShulkerBox || !this.shulkerOnly.get_value(true))) {
                AutoSalC1Dupe.mc.playerController.windowClick(p_WindowId, l_Y + p_Slot, 0, ClickType.QUICK_MOVE, (EntityPlayer)AutoSalC1Dupe.mc.player);
                return;
            }
        }
    }
    
    private void doDupe() {
        this.noBypass = true;
        final Entity l_Entity = (Entity)AutoSalC1Dupe.mc.world.loadedEntityList.stream().filter(this::isValidEntity).min(Comparator.comparing(p_Entity -> AutoSalC1Dupe.mc.player.getDistance(p_Entity))).orElse(null);
        if (l_Entity instanceof AbstractChestHorse) {
            AutoSalC1Dupe.mc.player.connection.sendPacket((Packet)new CPacketUseEntity(l_Entity, EnumHand.MAIN_HAND, l_Entity.getPositionVector()));
            this.noBypass = false;
            this.doDrop = true;
        }
    }
    
    private int getItemsToDupe() {
        int i = 0;
        for (int l_Y = 9; l_Y < AutoSalC1Dupe.mc.player.inventoryContainer.inventorySlots.size() - 1; ++l_Y) {
            final ItemStack l_InvStack = AutoSalC1Dupe.mc.player.inventoryContainer.getSlot(l_Y).getStack();
            if (!l_InvStack.isEmpty() && l_InvStack.getItem() != Items.AIR && (l_InvStack.getItem() instanceof ItemShulkerBox || !this.shulkerOnly.get_value(true))) {
                ++i;
            }
        }
        if (i > this.l_Chest.horseInventory.getSizeInventory() - 1) {
            i = this.l_Chest.horseInventory.getSizeInventory() - 1;
        }
        return i;
    }
    
    private int getItemsInRidingEntity() {
        int i = 0;
        for (int l_I = 2; l_I < this.l_Chest.horseInventory.getSizeInventory() + 1; ++l_I) {
            final ItemStack l_ItemStack = this.l_Chest.horseInventory.getStackInSlot(l_I);
            if (!l_ItemStack.isEmpty() && l_ItemStack.getItem() != Items.AIR) {
                ++i;
            }
        }
        return i;
    }
    
    private boolean canStore() {
        for (int l_Y = 9; l_Y < AutoSalC1Dupe.mc.player.inventoryContainer.inventorySlots.size() - 1; ++l_Y) {
            final ItemStack l_InvStack = AutoSalC1Dupe.mc.player.inventoryContainer.getSlot(l_Y).getStack();
            if (l_InvStack.isEmpty() || l_InvStack.getItem() == Items.AIR) {
                return true;
            }
        }
        return false;
    }
    
    public boolean ignoreMountBypass() {
        return this.noBypass;
    }
}
