//Deobfuscated with https://github.com/PetoPetko/Minecraft-Deobfuscator3000 using mappings "1.12 stable mappings"!

// 
// Decompiled by Procyon v0.5.36
// 

package me.travis.wurstplus.wurstplustwo.hacks.exploit;

import net.minecraft.block.Block;
import net.minecraft.world.World;
import net.minecraft.init.Blocks;
import java.util.Iterator;
import net.minecraft.network.Packet;
import net.minecraft.util.EnumHand;
import java.util.function.Predicate;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.client.CPacketAnimation;
import me.travis.wurstplus.wurstplustwo.hacks.WurstplusCategory;
import me.travis.wurstplus.wurstplustwo.event.events.WurstplusEventBlock;
import me.zero.alpine.fork.listener.EventHandler;
import me.travis.wurstplus.wurstplustwo.event.events.WurstplusEventPacket;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.BlockPos;
import net.minecraft.block.state.IBlockState;
import me.travis.wurstplus.wurstplustwo.util.WurstplusTimer;
import me.travis.wurstplus.wurstplustwo.guiscreen.settings.WurstplusSetting;
import me.travis.wurstplus.wurstplustwo.hacks.WurstplusHack;

public class WurstplusSpeedmine extends WurstplusHack
{
    WurstplusSetting mode;
    WurstplusSetting damage;
    WurstplusSetting reset;
    WurstplusSetting no_break_anim;
    WurstplusSetting no_delay;
    WurstplusSetting no_swing;
    WurstplusSetting allow;
    WurstplusSetting double_break;
    private final WurstplusTimer timer;
    private IBlockState current_block_state;
    private BlockPos current_pos;
    private BlockPos last_pos;
    private EnumFacing last_facing;
    private boolean is_mining;
    @EventHandler
    private Listener<WurstplusEventPacket.SendPacket> send_listener;
    @EventHandler
    private Listener<WurstplusEventBlock> block_event;
    
    public WurstplusSpeedmine() {
        super(WurstplusCategory.WURSTPLUS_EXPLOIT);
        this.mode = this.create("Mode", "SpeedmineMode", "Normal", this.combobox("Normal", "Packet", "Damage", "Instant"));
        this.damage = this.create("Damage Ammount", "SpeedmineDamagaeAmmount", 0.7, 0.0, 1.0);
        this.reset = this.create("Reset", "SpeedmineReset", true);
        this.no_break_anim = this.create("No Break Anim", "SpeedMineBreakAnim", false);
        this.no_delay = this.create("No Delay", "SpeedmineNoDelay", false);
        this.no_swing = this.create("No Swing", "SpeedmineNoSwing", false);
        this.allow = this.create("MultiTask", "SpeedmineMultiTask", false);
        this.double_break = this.create("Double Break", "SpeedmineDoubleBreak", false);
        this.timer = new WurstplusTimer();
        this.current_block_state = null;
        this.current_pos = null;
        this.last_pos = null;
        this.last_facing = null;
        this.is_mining = false;
        CPacketPlayerDigging p;
        final Iterator<Entity> iterator;
        Entity entity;
        this.send_listener = new Listener<WurstplusEventPacket.SendPacket>(event -> {
            if (this.no_swing.get_value(true) && event.get_packet() instanceof CPacketAnimation) {
                event.cancel();
            }
            if (this.no_break_anim.get_value(true) && event.get_packet() instanceof CPacketPlayerDigging) {
                p = (CPacketPlayerDigging)event.get_packet();
                try {
                    WurstplusSpeedmine.mc.world.getEntitiesWithinAABBExcludingEntity((Entity)null, new AxisAlignedBB(p.getPosition())).iterator();
                    while (iterator.hasNext()) {
                        entity = iterator.next();
                        if (entity instanceof EntityEnderCrystal) {
                            this.show_anim();
                            return;
                        }
                    }
                }
                catch (Exception ex) {}
                if (p.getAction().equals((Object)CPacketPlayerDigging.Action.START_DESTROY_BLOCK)) {
                    this.show_anim(true, p.getPosition(), p.getFacing());
                }
                if (p.getAction().equals((Object)CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK)) {
                    this.show_anim();
                }
            }
            return;
        }, (Predicate<WurstplusEventPacket.SendPacket>[])new Predicate[0]);
        BlockPos above;
        this.block_event = new Listener<WurstplusEventBlock>(event -> {
            if (event.get_stage() == 3 && this.reset.get_value(true) && WurstplusSpeedmine.mc.playerController.curBlockDamageMP > 0.1f) {
                WurstplusSpeedmine.mc.playerController.isHittingBlock = true;
            }
            if (event.get_stage() == 4 && !this.mode.in("Normal")) {
                if (canBreak(event.pos)) {
                    if (this.reset.get_value(true)) {
                        WurstplusSpeedmine.mc.playerController.isHittingBlock = false;
                    }
                    if (this.mode.in("Packet")) {
                        if (this.current_pos == null) {
                            this.current_pos = event.pos;
                            this.current_block_state = WurstplusSpeedmine.mc.world.getBlockState(this.current_pos);
                            this.timer.reset();
                        }
                        WurstplusSpeedmine.mc.player.swingArm(EnumHand.MAIN_HAND);
                        WurstplusSpeedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.pos, event.facing));
                        WurstplusSpeedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.pos, event.facing));
                        event.cancel();
                    }
                    if (this.mode.in("Damage") && WurstplusSpeedmine.mc.playerController.curBlockDamageMP >= this.damage.get_value(1)) {
                        WurstplusSpeedmine.mc.playerController.curBlockDamageMP = 1.0f;
                    }
                    if (this.mode.in("Instant")) {
                        WurstplusSpeedmine.mc.player.swingArm(EnumHand.MAIN_HAND);
                        WurstplusSpeedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.pos, event.facing));
                        WurstplusSpeedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.pos, event.facing));
                        WurstplusSpeedmine.mc.playerController.onPlayerDestroyBlock(event.pos);
                        WurstplusSpeedmine.mc.world.setBlockToAir(event.pos);
                    }
                }
                if (this.double_break.get_value(true)) {
                    above = event.pos.up();
                    if (canBreak(above) && WurstplusSpeedmine.mc.player.getDistance((double)above.getX(), (double)above.getY(), (double)above.getZ()) <= 5.0) {
                        WurstplusSpeedmine.mc.player.swingArm(EnumHand.MAIN_HAND);
                        WurstplusSpeedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, above, event.facing));
                        WurstplusSpeedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, above, event.facing));
                        WurstplusSpeedmine.mc.playerController.onPlayerDestroyBlock(above);
                        WurstplusSpeedmine.mc.world.setBlockToAir(above);
                    }
                }
            }
            return;
        }, (Predicate<WurstplusEventBlock>[])new Predicate[0]);
        this.name = "Speed Mine";
        this.tag = "SpeedMine";
        this.description = "mine faster";
    }
    
    @Override
    public void update() {
        if (this.current_pos != null && (!WurstplusSpeedmine.mc.world.getBlockState(this.current_pos).equals(this.current_block_state) || WurstplusSpeedmine.mc.world.getBlockState(this.current_pos).getBlock() == Blocks.AIR)) {
            this.current_pos = null;
            this.current_block_state = null;
        }
        if (this.no_delay.get_value(true)) {
            WurstplusSpeedmine.mc.playerController.blockHitDelay = 0;
        }
        if (this.is_mining && this.last_pos != null && this.last_facing != null && this.no_break_anim.get_value(true)) {
            WurstplusSpeedmine.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, this.last_pos, this.last_facing));
        }
        if (this.reset.get_value(true) && WurstplusSpeedmine.mc.gameSettings.keyBindUseItem.isKeyDown() && !this.allow.get_value(true)) {
            WurstplusSpeedmine.mc.playerController.isHittingBlock = false;
        }
    }
    
    public void show_anim(final boolean is_mining, final BlockPos last_pos, final EnumFacing last_facing) {
        this.is_mining = is_mining;
        this.last_pos = last_pos;
        this.last_facing = last_facing;
    }
    
    public void show_anim() {
        this.show_anim(false, null, null);
    }
    
    @Override
    public String array_detail() {
        return this.mode.get_current_value();
    }
    
    public static boolean canBreak(final BlockPos pos) {
        final IBlockState blockState = WurstplusSpeedmine.mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, (World)WurstplusSpeedmine.mc.world, pos) != -1.0f;
    }
}
